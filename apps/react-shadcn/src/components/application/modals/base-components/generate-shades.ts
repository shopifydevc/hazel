interface RgbColor {
	r: number // 0-255
	g: number // 0-255
	b: number // 0-255
}

interface HlsColor {
	h: number // 0-1
	l: number // 0-1 (Lightness)
	s: number // 0-1 (Saturation)
}

interface ShadeProfile {
	l: number // Lightness (0-1)
	s: number // Saturation (0-1)
}

// Output structure: A map where keys are shade numbers (e.g., "25", "50")
// and values are RgbColor objects.
type GeneratedRgbShades = {
	[shadeKey: string]: RgbColor
}

// This profile was generated by analyzing ALL Untitled UI color scales
// and averaging their Lightness and Saturation values for each step.
// Using HLS (L and S are 0-1).
const AVERAGE_LS_PROFILE: { [key: string]: ShadeProfile } = {
	"25": { l: 0.9849703526730965, s: 0.9001176556291033 },
	"50": { l: 0.9708185801085115, s: 0.8905531765476371 },
	"100": { l: 0.9418036802151213, s: 0.8685644666585649 },
	"200": { l: 0.8862115083306781, s: 0.8630646066188234 },
	"300": { l: 0.7957033841890612, s: 0.8518327074161965 },
	"400": { l: 0.6802157616091734, s: 0.8463861782888655 },
	"500": { l: 0.5806475842162854, s: 0.8228718907538995 },
	"600": { l: 0.4831984367669616, s: 0.8000447507957499 },
	"700": { l: 0.3997948381935986, s: 0.7982974833950593 },
	"800": { l: 0.3267005177428293, s: 0.7158461417930369 },
	"900": { l: 0.2716519942240829, s: 0.6607901436969497 },
	"950": { l: 0.17373629466082585, s: 0.6208249447015502 },
}

const SHADE_KEYS_ORDERED: string[] = [
	"25",
	"50",
	"100",
	"200",
	"300",
	"400",
	"500",
	"600",
	"700",
	"800",
	"900",
	"950",
]

/**
 * Converts a hex color string to an RGB object.
 * Accepts formats like #RRGGBB, RRGGBB, #RGB, RGB.
 * Returns null if the format is invalid.
 */
function hexToRgb(hexColor: string): RgbColor | null {
	let hex = hexColor.startsWith("#") ? hexColor.slice(1) : hexColor

	if (hex.length === 3) {
		hex = hex
			.split("")
			.map((char) => char + char)
			.join("")
	}

	if (hex.length !== 6) {
		console.error(`Invalid hex color format: "${hexColor}". Must be 3 or 6 digits after '#'.`)
		return null
	}

	const r = parseInt(hex.substring(0, 2), 16)
	const g = parseInt(hex.substring(2, 4), 16)
	const b = parseInt(hex.substring(4, 6), 16)

	if (isNaN(r) || isNaN(g) || isNaN(b)) {
		console.error(`Invalid characters in hex string "${hexColor}" resulting in NaN.`)
		return null
	}
	return { r, g, b }
}

/**
 * Converts an RGB color value to HLS.
 * Assumes r, g, and b are in the set [0, 255].
 * Returns h, l, and s in the set [0, 1].
 */
function rgbToHls({ r, g, b }: RgbColor): HlsColor {
	const rNorm = r / 255
	const gNorm = g / 255
	const bNorm = b / 255

	const max = Math.max(rNorm, gNorm, bNorm)
	const min = Math.min(rNorm, gNorm, bNorm)

	let h = 0,
		s = 0
	const l = (max + min) / 2

	if (max === min) {
		h = s = 0 // achromatic
	} else {
		const d = max - min
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min)

		switch (max) {
			case rNorm:
				h = (gNorm - bNorm) / d + (gNorm < bNorm ? 6 : 0)
				break
			case gNorm:
				h = (bNorm - rNorm) / d + 2
				break
			case bNorm:
				h = (rNorm - gNorm) / d + 4
				break
		}
		h /= 6
	}
	return { h, l, s }
}

/**
 * Converts an HLS color value to RGB.
 * Assumes h, l, and s are in the set [0, 1].
 * Returns r, g, and b in the set [0, 255].
 */
function hlsToRgb({ h, l, s }: HlsColor): RgbColor {
	let r: number, g: number, b: number

	if (s === 0) {
		r = g = b = l // achromatic
	} else {
		const hue2rgb = (p: number, q: number, t: number): number => {
			if (t < 0) t += 1
			if (t > 1) t -= 1
			if (t < 1 / 6) return p + (q - p) * 6 * t
			if (t < 1 / 2) return q
			if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6
			return p
		}

		const q = l < 0.5 ? l * (1 + s) : l + s - l * s
		const p = 2 * l - q

		r = hue2rgb(p, q, h + 1 / 3)
		g = hue2rgb(p, q, h)
		b = hue2rgb(p, q, h - 1 / 3)
	}

	return {
		r: Math.round(r * 255),
		g: Math.round(g * 255),
		b: Math.round(b * 255),
	}
}

/**
 * Generates a full set of 12 color shades as RGB objects,
 * based on the input hex color and the AVERAGE_LS_PROFILE.
 */
export function generateRgbShades(inputHexColor: string): GeneratedRgbShades | null {
	const rgbInput = hexToRgb(inputHexColor)
	if (!rgbInput) {
		// hexToRgb will console.error the issue
		return null
	}

	// We primarily need the Hue from the input. Lightness and Saturation will be overridden.
	const { h: hInput } = rgbToHls(rgbInput)

	const generatedShades: GeneratedRgbShades = {}

	for (const shadeKey of SHADE_KEYS_ORDERED) {
		const profile = AVERAGE_LS_PROFILE[shadeKey]
		if (!profile) {
			console.warn(`No profile found for shade key: ${shadeKey}`)
			continue
		}

		let targetL = profile.l
		let targetS = profile.s

		// Ensure L and S are clamped between 0 and 1
		targetL = Math.max(0.0, Math.min(1.0, targetL))
		targetS = Math.max(0.0, Math.min(1.0, targetS))

		const currentHls: HlsColor = { h: hInput, l: targetL, s: targetS }

		let { r: rOut, g: gOut, b: bOut } = hlsToRgb(currentHls)

		// Clamp final RGB values to ensure they are within 0-255
		rOut = Math.max(0, Math.min(255, rOut))
		gOut = Math.max(0, Math.min(255, gOut))
		bOut = Math.max(0, Math.min(255, bOut))

		generatedShades[shadeKey] = { r: rOut, g: gOut, b: bOut }
	}

	return generatedShades
}
